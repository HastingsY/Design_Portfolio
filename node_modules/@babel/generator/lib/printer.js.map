<<<<<<< HEAD
{"version":3,"names":["_buffer","require","_index","_nodes","_t","_tokenMap","_types2","isExpression","isFunction","isStatement","isClassBody","isTSInterfaceBody","isTSEnumMember","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","HAS_NEWLINE","HAS_NEWLINE_OR_BlOCK_COMMENT_END","commentIsNewline","c","type","test","value","Printer","constructor","format","map","tokens","originalCode","tokenContext","TokenContext","normal","_tokens","_originalCode","_currentNode","_currentTypeId","_indent","_indentRepeat","_insideAux","_noLineTerminator","_noLineTerminatorAfterNode","_printAuxAfterOnNextUserNode","_printedComments","Set","_lastCommentLine","_innerCommentsState","_flags","tokenMap","_boundGetRawIdentifier","_printSemicolonBeforeNextNode","_printSemicolonBeforeNextToken","indent","style","length","_inputMap","_buf","Buffer","preserveFormat","compact","concise","retainLines","retainFunctionParens","auxiliaryCommentBefore","auxiliaryCommentAfter","enterDelimited","oldNoLineTerminatorAfterNode","generate","ast","TokenMap","_getRawIdentifier","bind","print","_maybeAddAuxComment","get","flags","dedent","semicolon","force","node","start","end","endMatches","getCurrentLine","indexes","getIndexes","_catchUpTo","loc","_appendChar","_queue","rightBrace","minified","removeLastSemicolon","sourceWithOffset","token","rightParens","space","_space","lastCp","getLastChar","word","str","noLineTerminatorAfter","forInOrInitHeadAccumulatePassThroughMask","_maybePrintInnerComments","_catchUpToCurrentToken","lastChar","charCodeAt","_append","setLastChar","number","isNonDecimalLiteral","secondChar","Number","isInteger","maybeNewline","occurrenceCount","mayNeedSpace","strFirst","tokenChar","char","newline","i","getNewlineCount","j","_newline","endsWith","checkQueue","_last","exactSource","cb","_catchUp","source","prop","columnOffset","sourceIdentifierName","identifierName","pos","_canMarkIdName","sourcePosition","_sourcePosition","identifierNamePos","_queuedChar","findMatching","_maybeIndent","append","noIndent","appendChar","queue","_shouldIndent","catchUp","line","count","column","index","spacesCount","getCurrentColumn","spaces","slice","replace","repeat","printTerminatorless","resetTokenContext","trailingCommentsLineOffset","_node$leadingComments","_node$leadingComments2","extra","changedFlags","_compact","nodeInfo","generatorInfosMap","undefined","ReferenceError","JSON","stringify","name","printMethod","nodeId","needsParens","parent","parentId","oldInAux","oldTokenContext","forInOrInitHeadAccumulate","parenthesized","shouldPrintParens","parentNeedsParens","leadingComments","callee","indentParenthesized","some","isLastChild","_node$trailingComment","trailingComments","_printLeadingComments","_printTrailingComments","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","_printComment","getPossibleRaw","raw","rawValue","printJoin","nodes","statement","separator","printTrailingSeparator","_nodes$0$loc","startLine","len","hasContent","call","lastCommentLine","_nodes$loc","offset","printAndIndentOnComments","printBlock","body","lineOffset","innerComments","_printComments","comments","nextTokenStr","nextTokenOccurrenceCount","_this$tokenMap","state","printInnerComments","nextToken","hasSpace","noIndentInnerCommentsHere","printSequence","printList","items","commaSeparator","shouldPrintTrailingComma","listEnd","listEndIndex","findLastIndex","matchesOriginal","String","fromCharCode","_shouldPrintComment","ignore","has","commentTok","find","add","shouldPrintComment","skipNewLines","noLineTerminator","isBlockComment","printNewLines","val","adjustMultilineComment","_comment$loc","newlineRegex","RegExp","indentSize","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","Math","max","min","singleLine","shouldSkipNewline","properties","_default","exports","default","last"],"sources":["../src/printer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n\nimport Buffer from \"./buffer.ts\";\nimport type { Loc, Pos } from \"./buffer.ts\";\nimport { isLastChild, parentNeedsParens } from \"./node/index.ts\";\nimport { generatorInfosMap } from \"./nodes.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\n\nimport type { GeneratorOptions } from \"./index.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nimport { TokenContext } from \"./node/index.ts\";\nimport { _getRawIdentifier } from \"./generators/types.ts\";\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nconst enum PRINTER_FLAGS {\n  EMPTY = 0,\n  PRESERVE_FORMAT = 1 << 0,\n  COMPACT = 1 << 1,\n  CONCISE = 1 << 2,\n  RETAIN_LINES = 1 << 3,\n  RETAIN_FUNCTION_PARENS = 1 << 4,\n  AUX_COMMENTS = 1 << 5,\n}\n\nconst enum LAST_CHAR_KINDS {\n  EMPTY = 0,\n  NORMAL = -1,\n  INTEGER = -2,\n  WORD = -3,\n}\n\nconst enum INNER_COMMENTS_STATE {\n  DISALLOWED = 0,\n  ALLOWED = 1,\n  PRINTED = 2,\n\n  WITH_INDENT = 4,\n  MASK = 3,\n}\n\nconst enum PRINT_COMMENTS_RESULT {\n  PRINTED_NONE = 0,\n  PRINTED_SOME = 1,\n  PRINTED_ALL = 2,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean | undefined;\n  retainLines: boolean | undefined;\n  retainFunctionParens: boolean | undefined;\n  comments: boolean | undefined;\n  auxiliaryCommentBefore: string | undefined;\n  auxiliaryCommentAfter: string | undefined;\n  compact: boolean | \"auto\" | undefined;\n  minified: boolean | undefined;\n  concise: boolean | undefined;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  /**\n   * @deprecated Removed in Babel 8, syntax type is always 'hash'\n   */\n  recordAndTupleSyntaxType?: GeneratorOptions[\"recordAndTupleSyntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   * @deprecated Removed in Babel 8.\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface PrintSequenceOptions {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap | null,\n    tokens: Token[] | null = null,\n    originalCode: string | null = null,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap || null;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n\n    const {\n      preserveFormat,\n      compact,\n      concise,\n      retainLines,\n      retainFunctionParens,\n    } = format;\n    if (preserveFormat) {\n      this._flags |= PRINTER_FLAGS.PRESERVE_FORMAT;\n    }\n    if (compact) {\n      this._flags |= PRINTER_FLAGS.COMPACT;\n    }\n    if (concise) {\n      this._flags |= PRINTER_FLAGS.CONCISE;\n    }\n    if (retainLines) {\n      this._flags |= PRINTER_FLAGS.RETAIN_LINES;\n    }\n    if (retainFunctionParens) {\n      this._flags |= PRINTER_FLAGS.RETAIN_FUNCTION_PARENS;\n    }\n    if (format.auxiliaryCommentBefore || format.auxiliaryCommentAfter) {\n      this._flags |= PRINTER_FLAGS.AUX_COMMENTS;\n    }\n  }\n  declare _inputMap: TraceMap | null;\n\n  declare format: Format;\n\n  enterDelimited() {\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (oldNoLineTerminatorAfterNode !== null) {\n      this._noLineTerminatorAfterNode = null;\n    }\n    return oldNoLineTerminatorAfterNode;\n  }\n\n  tokenContext: number = TokenContext.normal;\n\n  _tokens: Token[] | null = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node | null = null;\n  _currentTypeId: number | null = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _lastCommentLine = 0;\n  _innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n  _flags = PRINTER_FLAGS.EMPTY;\n\n  tokenMap: TokenMap | null = null;\n\n  _boundGetRawIdentifier: ((node: t.Identifier) => string) | null = null;\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens!, this._originalCode!);\n      this._boundGetRawIdentifier = _getRawIdentifier.bind(this);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(flags = this._flags): void {\n    if (\n      flags &\n      (PRINTER_FLAGS.PRESERVE_FORMAT |\n        PRINTER_FLAGS.COMPACT |\n        PRINTER_FLAGS.CONCISE)\n    ) {\n      return;\n    }\n\n    this._indent += this._indentRepeat;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(flags = this._flags): void {\n    if (\n      flags &\n      (PRINTER_FLAGS.PRESERVE_FORMAT |\n        PRINTER_FLAGS.COMPACT |\n        PRINTER_FLAGS.CONCISE)\n    ) {\n      return;\n    }\n\n    this._indent -= this._indentRepeat;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    const flags = this._flags;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      const node = this._currentNode!;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap!.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap!.getIndexes(this._currentNode!)!;\n        this._catchUpTo(this._tokens![indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this._flags & (PRINTER_FLAGS.PRESERVE_FORMAT | PRINTER_FLAGS.COMPACT)) {\n      return;\n    }\n\n    if (force) {\n      this._space();\n    } else {\n      const lastCp = this.getLastChar(true);\n      if (\n        lastCp !== 0 &&\n        lastCp !== charCodes.space &&\n        lastCp !== charCodes.lineFeed\n      ) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str);\n\n    const flags = this._flags;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n\n    if (\n      lastChar === LAST_CHAR_KINDS.INTEGER ||\n      lastChar === LAST_CHAR_KINDS.WORD ||\n      // prevent concatenating words and creating // comment out of division and regex\n      (lastChar === charCodes.slash && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this.setLastChar(-3);\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted immediately after them.\n    if (\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot\n    ) {\n      this.setLastChar(LAST_CHAR_KINDS.INTEGER);\n    }\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(\n    str: string,\n    maybeNewline = false,\n    occurrenceCount = 0,\n    mayNeedSpace: boolean = false,\n  ): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    const flags = this._flags;\n\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._catchUpToCurrentToken(str, occurrenceCount);\n    }\n\n    if (mayNeedSpace) {\n      const strFirst = str.charCodeAt(0);\n      if (\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (((strFirst === charCodes.dash && str === \"--\") ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo) &&\n          this.getLastChar() === charCodes.exclamationMark) ||\n        // Need spaces for operators of the same kind to avoid: `a+++b`\n        (strFirst === charCodes.plusSign &&\n          this.getLastChar() === charCodes.plusSign) ||\n        (strFirst === charCodes.dash &&\n          this.getLastChar() === charCodes.dash) ||\n        // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n        (strFirst === charCodes.dot &&\n          this.getLastChar() === LAST_CHAR_KINDS.INTEGER)\n      ) {\n        this._space();\n      }\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number, occurrenceCount = 0): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(char, occurrenceCount);\n\n    const flags = this._flags;\n\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._catchUpToCurrentToken(char, occurrenceCount);\n    }\n\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign &&\n        this.getLastChar() === charCodes.plusSign) ||\n      (char === charCodes.dash && this.getLastChar() === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this.getLastChar() === LAST_CHAR_KINDS.INTEGER)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, flags = this._flags): void {\n    if (i <= 0) return;\n\n    if (flags & (PRINTER_FLAGS.RETAIN_LINES | PRINTER_FLAGS.COMPACT)) {\n      return;\n    }\n\n    if (flags & PRINTER_FLAGS.CONCISE) {\n      this.space();\n      return;\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar(true) === char;\n  }\n\n  getLastChar(checkQueue?: boolean): number {\n    return this._buf.getLastChar(checkQueue);\n  }\n\n  setLastChar(char: number) {\n    this._buf._last = char;\n  }\n\n  exactSource(loc: Loc | null | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | null | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (this._buf._queuedChar === charCodes.space) this._buf._queuedChar = 0;\n\n    this._appendChar(charCodes.lineFeed, true);\n  }\n\n  _catchUpToCurrentToken(\n    str: string | number,\n    occurrenceCount: number = 0,\n  ): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap!.findMatching(\n      this._currentNode!,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._appendChar(charCodes.semicolon, true);\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent();\n\n    this._buf.append(str, maybeNewline);\n  }\n\n  _appendChar(char: number, noIndent?: boolean): void {\n    if (!noIndent) {\n      this._maybeIndent();\n    }\n\n    this._buf.appendChar(char);\n  }\n\n  _queue(char: typeof charCodes.space | typeof charCodes.semicolon): void {\n    this._buf.queue(char);\n\n    this.setLastChar(-1);\n  }\n\n  _maybeIndent(): void {\n    const indent = this._shouldIndent();\n    if (indent > 0) {\n      this._buf._appendChar(-1, indent, false);\n    }\n  }\n\n  _shouldIndent() {\n    // we've got a newline before us so prepend on the indentation\n    return this.endsWith(charCodes.lineFeed) ? this._indent : 0;\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const flags = this._flags;\n    if ((flags & PRINTER_FLAGS.PRESERVE_FORMAT) === 0) {\n      if (flags & PRINTER_FLAGS.RETAIN_LINES && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n      this.setLastChar(charCodes.space);\n    }\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null | undefined,\n    noLineTerminatorAfter: boolean = false,\n    resetTokenContext: boolean = false,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n\n    const { type, loc, extra } = node;\n\n    const flags = this._flags;\n    let changedFlags = false;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      this._flags |= PRINTER_FLAGS.CONCISE;\n      changedFlags = true;\n    }\n\n    const nodeInfo = generatorInfosMap.get(type);\n    if (nodeInfo === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          type,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const [printMethod, nodeId, needsParens] = nodeInfo;\n\n    const parent = this._currentNode;\n    const parentId = this._currentTypeId;\n    this._currentNode = node;\n    this._currentTypeId = nodeId;\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    let oldInAux;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      oldInAux = this._insideAux;\n      this._insideAux = loc == null;\n      this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    }\n\n    let oldTokenContext = 0;\n    if (resetTokenContext) {\n      oldTokenContext = this.tokenContext;\n      if (oldTokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        this.tokenContext = 0;\n      } else {\n        oldTokenContext = 0;\n      }\n    }\n\n    const parenthesized =\n      extra != null && (extra.parenthesized as boolean | undefined);\n    let shouldPrintParens =\n      (parenthesized && flags & PRINTER_FLAGS.PRESERVE_FORMAT) ||\n      (parenthesized &&\n        flags & PRINTER_FLAGS.RETAIN_FUNCTION_PARENS &&\n        nodeId === __node(\"FunctionExpression\")) ||\n      (parent &&\n        (parentNeedsParens(node, parent, parentId!) ||\n          // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n          (needsParens != null &&\n            needsParens(\n              node,\n              parent,\n              parentId!,\n              this.tokenContext,\n              flags & PRINTER_FLAGS.PRESERVE_FORMAT\n                ? this._boundGetRawIdentifier!\n                : undefined,\n            ))));\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      switch (parentId) {\n        case __node(\"ExpressionStatement\"):\n        case __node(\"VariableDeclarator\"):\n        case __node(\"AssignmentExpression\"):\n        case __node(\"ReturnStatement\"):\n          break;\n        case __node(\"CallExpression\"):\n        case __node(\"OptionalCallExpression\"):\n        case __node(\"NewExpression\"):\n          // @ts-expect-error checked by parentTypeId\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (flags & PRINTER_FLAGS.RETAIN_LINES &&\n          loc &&\n          loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        !!parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n      if (!resetTokenContext) {\n        oldTokenContext = this.tokenContext;\n      }\n      if (oldTokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        this.tokenContext = 0;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n\n    this._printLeadingComments(node, parent);\n\n    this.exactSource(\n      nodeId === __node(\"Program\") || nodeId === __node(\"File\") ? null : loc,\n      printMethod.bind(this, node, parent),\n    );\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n    if (oldTokenContext) this.tokenContext = oldTokenContext;\n\n    // end\n    this._currentNode = parent;\n    this._currentTypeId = parentId;\n    if (changedFlags) {\n      this._flags = flags;\n    }\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._insideAux = oldInAux!;\n    }\n\n    if (oldNoLineTerminatorAfterNode != null) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n\n    this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: t.Node[] | undefined | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintJoinOptions[\"separator\"] | null,\n    printTrailingSeparator?: boolean | null,\n    resetTokenContext?: boolean,\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!nodes?.length) return;\n\n    const flags = this._flags;\n\n    if (indent == null && flags & PRINTER_FLAGS.RETAIN_LINES) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent(flags);\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      // don't add newlines at the beginning of the file\n      if (statement && i === 0 && this._buf.hasContent()) {\n        this.newline(1, flags);\n      }\n\n      this.print(\n        node,\n        false,\n        resetTokenContext,\n        trailingCommentsLineOffset || 0,\n      );\n\n      if (separator != null) {\n        if (i < len - 1) separator.call(this, i, false);\n        else if (printTrailingSeparator) separator.call(this, i, true);\n      }\n\n      if (statement) {\n        if (i + 1 === len) {\n          this.newline(1, flags);\n        } else {\n          const lastCommentLine = this._lastCommentLine;\n          if (lastCommentLine > 0) {\n            const offset =\n              (nodes[i + 1].loc?.start.line || 0) - lastCommentLine;\n            if (offset >= 0) {\n              this.newline(offset || 1, flags);\n              continue;\n            }\n          }\n\n          this.newline(1, flags);\n        }\n      }\n    }\n\n    if (indent) this.dedent(flags);\n  }\n\n  printAndIndentOnComments(node: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n\n  printBlock(body: t.Statement) {\n    if (body.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(body);\n  }\n\n  _printTrailingComments(\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset?: number,\n  ) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    } else {\n      this._lastCommentLine = 0;\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node | null) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments(\n    nextTokenStr: string | number,\n    nextTokenOccurrenceCount?: number,\n  ) {\n    const state = this._innerCommentsState;\n    switch (state & INNER_COMMENTS_STATE.MASK) {\n      case INNER_COMMENTS_STATE.DISALLOWED:\n        this._innerCommentsState =\n          INNER_COMMENTS_STATE.ALLOWED | INNER_COMMENTS_STATE.WITH_INDENT;\n        return;\n      case INNER_COMMENTS_STATE.ALLOWED:\n        this.printInnerComments(\n          (state & INNER_COMMENTS_STATE.WITH_INDENT) > 0,\n          this.tokenMap?.findMatching(\n            this._currentNode!,\n            nextTokenStr,\n            nextTokenOccurrenceCount,\n          ),\n        );\n    }\n  }\n\n  printInnerComments(indent = true, nextToken?: Token | null) {\n    const node = this._currentNode!;\n    const comments = node.innerComments;\n    if (!comments?.length) {\n      this._innerCommentsState = INNER_COMMENTS_STATE.PRINTED;\n      return;\n    }\n\n    const hasSpace = this.endsWith(charCodes.space);\n    if (indent) this.indent();\n\n    switch (\n      this._printComments(\n        COMMENT_TYPE.INNER,\n        comments,\n        node,\n        undefined,\n        undefined,\n        nextToken,\n      )\n    ) {\n      case PRINT_COMMENTS_RESULT.PRINTED_ALL:\n        this._innerCommentsState = INNER_COMMENTS_STATE.PRINTED;\n      // falls through\n      case PRINT_COMMENTS_RESULT.PRINTED_SOME:\n        if (hasSpace) this.space();\n    }\n\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._innerCommentsState &= ~INNER_COMMENTS_STATE.WITH_INDENT;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    indent?: boolean,\n    resetTokenContext?: boolean,\n    trailingCommentsLineOffset?: number,\n  ) {\n    this.printJoin(\n      nodes,\n      true,\n      indent ?? false,\n      undefined,\n      undefined,\n      resetTokenContext,\n      trailingCommentsLineOffset,\n    );\n  }\n\n  printList(\n    items: t.Node[] | null | undefined,\n    printTrailingSeparator?: boolean | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintListOptions[\"separator\"],\n    resetTokenContext?: boolean,\n  ) {\n    this.printJoin(\n      items,\n      statement,\n      indent,\n      separator ?? commaSeparator,\n      printTrailingSeparator,\n      resetTokenContext,\n    );\n  }\n\n  shouldPrintTrailingComma(listEnd: string | number): boolean | null {\n    if (!this.tokenMap) return null;\n\n    const listEndIndex = this.tokenMap.findLastIndex(\n      this._currentNode!,\n      token =>\n        this.tokenMap!.matchesOriginal(\n          token,\n          typeof listEnd === \"number\" ? String.fromCharCode(listEnd) : listEnd,\n        ),\n    );\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens![listEndIndex - 1], \",\");\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(\n    comment: t.Comment,\n    nextToken?: Token | null,\n  ): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(\n        this._currentNode!,\n        token => token.value === comment.value,\n      );\n      if (commentTok && commentTok.start > nextToken.start) {\n        return PRINT_COMMENT_HINT.DEFER;\n      }\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    switch (this.getLastChar(true)) {\n      // Avoid converting a / operator into a line comment by appending /* to it\n      case charCodes.slash:\n        this._space();\n      // falls through\n      case charCodes.leftSquareBracket:\n      case charCodes.leftCurlyBrace:\n      case charCodes.leftParenthesis:\n        break;\n\n      default:\n        this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this._flags & PRINTER_FLAGS.CONCISE) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent() || this.format.retainLines) {\n            indentSize += this._indent;\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n\n    if (!isBlockComment && !noLineTerminator) {\n      this._newline();\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: t.Comment[],\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset: number = 0,\n    nextToken?: Token | null,\n  ): PRINT_COMMENTS_RESULT {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc!.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc!.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const { _noLineTerminator, _flags } = this;\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        return i === 0\n          ? PRINT_COMMENTS_RESULT.PRINTED_NONE\n          : PRINT_COMMENTS_RESULT.PRINTED_SOME;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine !== commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          if (offset > 0 && !_noLineTerminator) {\n            this.newline(offset, _flags);\n          }\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            const count = Math.max(\n              nodeStartLine - lastLine,\n              leadingCommentNewline,\n            );\n            if (count > 0 && !_noLineTerminator) {\n              this.newline(count, _flags);\n            }\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          if (offset > 0 && !_noLineTerminator) {\n            this.newline(offset, _flags);\n          }\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            const count = Math.min(1, nodeEndLine - lastLine);\n            if (count > 0 && !_noLineTerminator) {\n              this.newline(count, _flags);\n            }\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          if (offset > 0 && !_noLineTerminator) {\n            this.newline(offset, _flags);\n          }\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumMember(node);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent) && parent.body === node)\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n    return PRINT_COMMENTS_RESULT.PRINTED_ALL;\n  }\n}\n\nexport default Printer;\n\nfunction commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {\n  this.tokenChar(charCodes.comma, occurrenceCount);\n  if (!last) this.space();\n}\n"],"mappings":"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","ignoreList":[]}
=======
{"version":3,"names":["_buffer","require","_index","n","_t","_tokenMap","generatorFunctions","_deprecated","isExpression","isFunction","isStatement","isClassBody","isTSInterfaceBody","isTSEnumMember","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","HAS_NEWLINE","HAS_NEWLINE_OR_BlOCK_COMMENT_END","commentIsNewline","c","type","test","value","needsParens","Printer","constructor","format","map","tokens","originalCode","tokenContext","TokenContext","normal","_tokens","_originalCode","_currentNode","_indent","_indentRepeat","_insideAux","_noLineTerminator","_noLineTerminatorAfterNode","_printAuxAfterOnNextUserNode","_printedComments","Set","_endsWithInteger","_endsWithWord","_endsWithDiv","_lastCommentLine","_endsWithInnerRaw","_indentInnerComments","tokenMap","_boundGetRawIdentifier","_getRawIdentifier","bind","_printSemicolonBeforeNextNode","_printSemicolonBeforeNextToken","indent","style","length","_inputMap","_buf","Buffer","enterForStatementInit","forInitHead","forInOrInitHeadAccumulate","enterForXStatementInit","isForOf","forOfHead","forInHead","enterDelimited","oldTokenContext","oldNoLineTerminatorAfterNode","generate","ast","preserveFormat","TokenMap","print","_maybeAddAuxComment","get","compact","concise","dedent","semicolon","force","_appendChar","node","start","end","endMatches","getCurrentLine","indexes","getIndexes","_catchUpTo","loc","_queue","rightBrace","minified","removeLastSemicolon","sourceWithOffset","token","rightParens","space","_space","hasContent","lastCp","getLastChar","word","str","noLineTerminatorAfter","forInOrInitHeadAccumulatePassThroughMask","_maybePrintInnerComments","_catchUpToCurrentToken","charCodeAt","_append","number","isNonDecimalLiteral","secondChar","Number","isInteger","maybeNewline","occurrenceCount","lastChar","strFirst","tokenChar","char","String","fromCharCode","newline","i","retainLines","getNewlineCount","j","_newline","endsWith","endsWithCharAndNewline","removeTrailingNewline","exactSource","cb","_catchUp","source","prop","columnOffset","sourceIdentifierName","identifierName","pos","_canMarkIdName","sourcePosition","_sourcePosition","identifierNamePos","findMatching","appendChar","_maybeIndent","append","queue","firstChar","queueIndentation","_getIndent","_shouldIndent","catchUp","line","count","column","index","spacesCount","getCurrentColumn","spaces","slice","replace","repeat","printTerminatorless","trailingCommentsLineOffset","_node$extra","_node$leadingComments","_node$leadingComments2","nodeType","oldConcise","_compact","printMethod","undefined","ReferenceError","JSON","stringify","name","parent","oldInAux","parenthesized","extra","shouldPrintParens","retainFunctionParens","leadingComments","parentType","callee","indentParenthesized","some","isLastChild","_node$trailingComment","trailingComments","_printLeadingComments","_printTrailingComments","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","statement","separator","printTrailingSeparator","iterator","_nodes$0$loc","startLine","newlineOpts","nextNodeStartLine","boundSeparator","len","_printNewline","_node$trailingComment2","_nextNode$loc","nextNode","printAndIndentOnComments","printBlock","body","lineOffset","innerComments","_printComments","comments","nextTokenStr","nextTokenOccurrenceCount","_this$tokenMap","printInnerComments","nextToken","hasSpace","printedCommentsCount","size","noIndentInnerCommentsHere","printSequence","printList","items","commaSeparator","shouldPrintTrailingComma","listEnd","listEndIndex","findLastIndex","matchesOriginal","newLine","opts","lastCommentLine","offset","_shouldPrintComment","ignore","has","commentTok","find","add","shouldPrintComment","skipNewLines","noLineTerminator","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","_comment$loc","newlineRegex","RegExp","indentSize","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","Math","max","min","singleLine","shouldSkipNewline","properties","Object","assign","prototype","addDeprecatedGenerators","_default","exports","default","last"],"sources":["../src/printer.ts"],"sourcesContent":["import Buffer, { type Pos } from \"./buffer.ts\";\nimport type { Loc } from \"./buffer.ts\";\nimport * as n from \"./node/index.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\nimport type { GeneratorOptions } from \"./index.ts\";\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport {\n  addDeprecatedGenerators,\n  type DeprecatedBabel7ASTTypes,\n} from \"./generators/deprecated.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nconst { needsParens } = n;\n\nimport { TokenContext } from \"./node/index.ts\";\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean | undefined;\n  retainLines: boolean | undefined;\n  retainFunctionParens: boolean | undefined;\n  comments: boolean | undefined;\n  auxiliaryCommentBefore: string | undefined;\n  auxiliaryCommentAfter: string | undefined;\n  compact: boolean | \"auto\" | undefined;\n  minified: boolean | undefined;\n  concise: boolean | undefined;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  /**\n   * @deprecated Removed in Babel 8, syntax type is always 'hash'\n   */\n  recordAndTupleSyntaxType?: GeneratorOptions[\"recordAndTupleSyntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   * @deprecated Removed in Babel 8.\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap | null,\n    tokens: Token[] | null = null,\n    originalCode: string | null = null,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap || null;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n  }\n  declare _inputMap: TraceMap | null;\n\n  declare format: Format;\n\n  enterForStatementInit() {\n    this.tokenContext |=\n      TokenContext.forInitHead | TokenContext.forInOrInitHeadAccumulate;\n    return () => (this.tokenContext = TokenContext.normal);\n  }\n\n  enterForXStatementInit(isForOf: boolean) {\n    if (isForOf) {\n      this.tokenContext |= TokenContext.forOfHead;\n      return null;\n    } else {\n      this.tokenContext |=\n        TokenContext.forInHead | TokenContext.forInOrInitHeadAccumulate;\n      return () => (this.tokenContext = TokenContext.normal);\n    }\n  }\n\n  enterDelimited() {\n    const oldTokenContext = this.tokenContext;\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (\n      !(oldTokenContext & TokenContext.forInOrInitHeadAccumulate) &&\n      oldNoLineTerminatorAfterNode === null\n    ) {\n      return () => {};\n    }\n    this._noLineTerminatorAfterNode = null;\n    this.tokenContext = TokenContext.normal;\n    return () => {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n      this.tokenContext = oldTokenContext;\n    };\n  }\n\n  tokenContext: number = TokenContext.normal;\n\n  _tokens: Token[] | null = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node | null = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _endsWithDiv = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n  tokenMap: TokenMap | null = null;\n\n  _boundGetRawIdentifier = this._getRawIdentifier.bind(this);\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens!, this._originalCode!);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent--;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n      this._noLineTerminator = false;\n      return;\n    }\n    if (this.tokenMap) {\n      const node = this._currentNode!;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap.getIndexes(this._currentNode!)!;\n        this._catchUpTo(this._tokens![indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    this._queue(charCodes.semicolon);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    const { format } = this;\n    if (format.compact || format.preserveFormat) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (this._endsWithDiv && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(str: string, maybeNewline = false, occurrenceCount = 0): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark &&\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    const str = String.fromCharCode(char);\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number | undefined {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | null | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | null | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _catchUpToCurrentToken(str: string, occurrenceCount: number = 0): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap!.findMatching(\n      this._currentNode!,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._buf.appendChar(charCodes.semicolon);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n      this._endsWithDiv = false;\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _queue(char: number) {\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const { format } = this;\n    if (!format.preserveFormat) {\n      if (format.retainLines && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null | undefined,\n    noLineTerminatorAfter: boolean = false,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          | DeprecatedBabel7ASTTypes\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const parent = this._currentNode;\n    this._currentNode = node;\n\n    if (this.tokenMap) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == null;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const parenthesized = node.extra?.parenthesized as boolean | undefined;\n    let shouldPrintParens =\n      (parenthesized && format.preserveFormat) ||\n      (parenthesized &&\n        format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\") ||\n      needsParens(\n        node,\n        parent,\n        this.tokenContext,\n        format.preserveFormat ? this._boundGetRawIdentifier : undefined,\n      );\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      const parentType = parent?.type;\n      switch (parentType) {\n        case \"ExpressionStatement\":\n        case \"VariableDeclarator\":\n        case \"AssignmentExpression\":\n        case \"ReturnStatement\":\n          break;\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"NewExpression\":\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (this.format.retainLines &&\n          node.loc &&\n          node.loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    let oldTokenContext;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        !!parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        n.isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._endsWithInnerRaw = false;\n      if (this.tokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        oldTokenContext = this.tokenContext;\n        this.tokenContext = TokenContext.normal;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(\n      loc,\n      // @ts-expect-error Expected 1 arguments, but got 3.\n      printMethod.bind(this, node, parent),\n    );\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n      if (oldTokenContext) this.tokenContext = oldTokenContext;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._currentNode = parent;\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    if (oldNoLineTerminatorAfterNode !== undefined) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: t.Node[] | undefined | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintJoinOptions[\"separator\"] | null,\n    printTrailingSeparator?: boolean | null,\n    iterator?: PrintJoinOptions[\"iterator\"] | null,\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!nodes?.length) return;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      nextNodeStartLine: 0,\n    };\n\n    const boundSeparator = separator?.bind(this);\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, undefined, trailingCommentsLineOffset || 0);\n\n      iterator?.(node, i);\n\n      if (boundSeparator != null) {\n        if (i < len - 1) boundSeparator(i, false);\n        else if (printTrailingSeparator) boundSeparator(i, true);\n      }\n\n      if (statement) {\n        if (!node.trailingComments?.length) {\n          this._lastCommentLine = 0;\n        }\n\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node);\n  }\n\n  _printTrailingComments(\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset?: number,\n  ) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node | null) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments(\n    nextTokenStr: string,\n    nextTokenOccurrenceCount?: number,\n  ) {\n    if (this._endsWithInnerRaw) {\n      this.printInnerComments(\n        this.tokenMap?.findMatching(\n          this._currentNode!,\n          nextTokenStr,\n          nextTokenOccurrenceCount,\n        ),\n      );\n    }\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments(nextToken?: Token | null) {\n    const node = this._currentNode!;\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(\n      COMMENT_TYPE.INNER,\n      comments,\n      node,\n      undefined,\n      undefined,\n      nextToken,\n    );\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    indent?: boolean,\n    trailingCommentsLineOffset?: number,\n  ) {\n    this.printJoin(\n      nodes,\n      true,\n      indent ?? false,\n      undefined,\n      undefined,\n      undefined,\n      trailingCommentsLineOffset,\n    );\n  }\n\n  printList(\n    items: t.Node[] | null | undefined,\n    printTrailingSeparator?: boolean | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintListOptions[\"separator\"],\n    iterator?: PrintListOptions[\"iterator\"],\n  ) {\n    this.printJoin(\n      items,\n      statement,\n      indent,\n      separator ?? commaSeparator,\n      printTrailingSeparator,\n      iterator,\n    );\n  }\n\n  shouldPrintTrailingComma(listEnd: string): boolean | null {\n    if (!this.tokenMap) return null;\n\n    const listEndIndex = this.tokenMap.findLastIndex(\n      this._currentNode!,\n      token => this.tokenMap!.matchesOriginal(token, listEnd),\n    );\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens![listEndIndex - 1], \",\");\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(\n    comment: t.Comment,\n    nextToken?: Token | null,\n  ): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(\n        this._currentNode!,\n        token => token.value === comment.value,\n      );\n      if (commentTok && commentTok.start > nextToken.start) {\n        return PRINT_COMMENT_HINT.DEFER;\n      }\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace &&\n      lastCharCode !== charCodes.leftParenthesis\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid converting a / operator into a line comment by appending /* to it\n    if (this._endsWithDiv) this._space();\n\n    if (this.tokenMap) {\n      const { _printSemicolonBeforeNextToken, _printSemicolonBeforeNextNode } =\n        this;\n      this._printSemicolonBeforeNextToken = -1;\n      this._printSemicolonBeforeNextNode = -1;\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n      this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;\n      this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;\n    } else {\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n    }\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset: number = 0,\n    nextToken?: Token | null,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc!.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc!.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine !== commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumMember(node);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  addDeprecatedGenerators(Printer);\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {\n  this.token(\",\", false, occurrenceCount);\n  if (!last) this.space();\n}\n"],"mappings":"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","ignoreList":[]}
>>>>>>> 0fa1ede365580cd1c41854b7dd1a840f088c4810
